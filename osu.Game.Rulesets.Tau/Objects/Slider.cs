using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using Newtonsoft.Json;
using osu.Framework.Bindables;
using osu.Game.Audio;
using osu.Game.Beatmaps;
using osu.Game.Beatmaps.ControlPoints;
using osu.Game.Rulesets.Objects;
using osu.Game.Rulesets.Objects.Types;
using osu.Game.Rulesets.Scoring;
using osuTK;

namespace osu.Game.Rulesets.Tau.Objects
{
    public class Slider : TauHitObject, IHasRepeats, IHasAngle
    {
        public double Duration
        {
            get => Nodes.Max(n => n.Time);
            set { }
        }

        public double EndTime => StartTime + Duration;

        [JsonIgnore]
        public SliderHeadBeat HeadBeat { get; protected set; }

        public BindableList<SliderNode> Nodes { get; set; }

        public float Angle
        {
            get => Nodes[0].Angle;
            set => throw new InvalidOperationException("Cannot set a slider's angle");
        }

        private SliderPath path;

        [JsonIgnore]
        public SliderPath Path
        {
            get
            {
                if (path != null)
                    return path;

                var positions = Nodes.Select(node => new Vector2(node.Time, node.Angle)).ToList();
                return path = new SliderPath(PathType.Linear, positions.ToArray());
            }
        }

        /// <summary>
        /// The length of one span of this <see cref="Slider"/>.
        /// </summary>
        public double SpanDuration => Duration / this.SpanCount();

        /// <summary>
        /// Velocity of this <see cref="Slider"/>.
        /// </summary>
        public double Velocity { get; private set; }

        /// <summary>
        /// Spacing between <see cref="SliderTick"/>s of this <see cref="Slider"/>.
        /// </summary>
        public double TickDistance { get; private set; }

        /// <summary>
        /// An extra multiplier that affects the number of <see cref="SliderTick"/>s generated by this <see cref="Slider"/>.
        /// An increase in this value increases <see cref="TickDistance"/>, which reduces the number of ticks generated.
        /// </summary>
        public double TickDistanceMultiplier = 4;

        public const int BASE_SCORING_DISTANCE = 100;

        protected override void ApplyDefaultsToSelf(ControlPointInfo controlPointInfo, IBeatmapDifficultyInfo difficulty)
        {
            base.ApplyDefaultsToSelf(controlPointInfo, difficulty);

            TimingControlPoint timingPoint = controlPointInfo.TimingPointAt(StartTime);

            Velocity = BASE_SCORING_DISTANCE / timingPoint.BeatLength;
            TickDistance = BASE_SCORING_DISTANCE / difficulty.SliderTickRate * TickDistanceMultiplier;
        }

        protected override void CreateNestedHitObjects(CancellationToken cancellationToken)
        {
            base.CreateNestedHitObjects(cancellationToken);

            var sliderEvents = SliderEventGenerator.Generate(StartTime, SpanDuration, Velocity, TickDistance, Duration, this.SpanCount(), null, cancellationToken);

            foreach (var e in sliderEvents)
            {
                switch (e.Type)
                {
                    case SliderEventType.Head:
                        AddNested(HeadBeat = new SliderHeadBeat
                        {
                            StartTime = StartTime,
                            Angle = Nodes[0].Angle
                        });
                        break;

                    case SliderEventType.Repeat:
                        var time = (e.SpanIndex + 1) * SpanDuration;
                        var pos = Path.PositionAt(time / Duration);
                        AddNested(new SliderRepeat
                        {
                            RepeatIndex = e.SpanIndex,
                            StartTime = StartTime + time,
                            Angle = pos.Y
                        });
                        break;
                }
            }

            updateNestedSamples();
        }

        private void updateNestedSamples()
        {
            if (HeadBeat != null)
                HeadBeat.Samples = this.GetNodeSamples(0);

            foreach (var repeat in NestedHitObjects.OfType<SliderRepeat>())
                repeat.Samples = this.GetNodeSamples(repeat.RepeatIndex + 1);
        }

        protected override HitWindows CreateHitWindows() => HitWindows.Empty;

        public int RepeatCount { get; set; }
        public IList<IList<HitSampleInfo>> NodeSamples { get; set; } = new List<IList<HitSampleInfo>>();

        public readonly struct SliderNode : IComparable<SliderNode>
        {
            public float Time { get; }

            public float Angle { get; }

            public SliderNode(float time, float angle)
            {
                Time = time;
                Angle = angle;
            }

            public int CompareTo(SliderNode other) => Time.CompareTo(other.Time);
        }
    }
}
